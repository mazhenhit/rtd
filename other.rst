
功能
====

.. contents::
   :depth: 3
..

记录
----

记录大小限制
~~~~~~~~~~~~

DB2能够插入的最大记录不能超过pagesize，即最大记录为32K，否则在建表时会报错。MySQL能够插入的最大记录不能超过pagesize的一半，即最大记录为8K。如果MySQL最大记录超过8K，在建表时不会报错，但是插入超过8K的记录时会报错。

索引大小限制
~~~~~~~~~~~~

在默认16Kpagesize下，单列索引字段大小不能超过767B；组合索引字段总大小不能超过3072B，且每一列大小都不能超过767B，如果表格索引字段大小超过限制会导致建表语句报错。如果在其他pagesize下，索引字段大小限制按比例减小。

整型显示长度
~~~~~~~~~~~~

mysql支持整型数据类型的显示长度扩展选项，例如INT(4)表示该字段为INT型，至少显示4个字符，该选项有如下特点：

1. 该选项不影响字段的取值范围，只表示显示的最少位数
2. 默认情况下，位数不足时使用空格补足位数
3. 使用SMALLINT(3)
   ZEROFILL这种格式的定义可以用0补位，类似003的显示格式（自动添加UNSIGNED属性）

字符集
------

MySQL可以为每个数据库字段设置字符集和字符序。如无特殊需求，建议使用utf-8字符集。

字符集（Character Set）
~~~~~~~~~~~~~~~~~~~~~~~

MySQL字符集牵涉较广，最关键的是数据库字段的字符集(集成自表属性)，客户端、数据库连接和应答报文也可以设置字符集(编码)，建议这几处都使用与数据库字符集一致，如果不一致MySQL会根据声明或设置的字符集进行转码。

MySQL中VARChar/Char类型为字符，DB2中为字节，具体表现在如下几点：

1. VARCHAR(n)和CHAR(n)，其中计数n为字符数量。例如,若字符集gbk，字段设计为char(10),则表示最大存储为10个汉字。
2. 字符集(编码)校验。如果写入时字符编码非申明编码，则会报错，或内容被截断。
3. 避免字符集校验。使用binary和varbinary分别代替char和varchar来避免字符集校验。

字符序（Collation）
~~~~~~~~~~~~~~~~~~~

字符序用于决定比较（排序）规则，一个具体的表现为：

1. 一般\*\_bin的字符序才区分字母大小写。而默认字符序\*\_ci往往不区分。

SQL模式
-------

介绍3个建议SQL模式选项：

1. ``PAD_CHAR_TO_FULL_LENGTH``\ ：对于CHAR类型的字符串，MySQL数据库会自动对存储列的右边进行填充（Right
   Padded）操作，直到字符串达到指定的长度N。而在读取该列时，MySQL数据库会自动将填充的字符删除。有一种情况例外，那就是显式地将\ ``SQL_MODE``\ 添加选项\ ``PAD_CHAR_TO_FULL_LENGTH``\ 。

2. ``NO_BACKSLASH_ESCAPES``\ ：DB2不会自动转义转义字符，以\ ``\n``\ 为例，存入字符\ ``a\nb``\ 读出仍为\ ``a\nb``\ 。MySQL会自动转义转义字符，从DB2向MySQL迁移数据时如果数据中包含转义字符，会导致数据迁移后不可用。如果要求MySQL与DB2一致，不要自动转义转义字符，需要在\ ``SQL_MODE``\ 中添加\ ``NO_BACKSLASH_ESCAPES``\ 选项。

3. ``STRICT_TRANS_TABLES``\ ：主要有如下影响：

   -  语句中对于非空字段需要赋值或者设置默认值，否则会报错;
   -  语句错误（值非法或丢失），如本条语句为事务内第一条语句，则回滚本条语句;
   -  语句错误（值非法或丢失），如本条语句非本事务内第一条语句。mysql会将非法值转为最相近的合法值(丢失使用默认值)。mysql给出一条警告后，继续执行语句。

如需兼容DB2的特性，建议设置参数sql\_mode为：

.. code:: sql

    sql_mode="STRICT_TRANS_TABLES,PAD_CHAR_TO_FULL_LENGTH,
    NO_BACKSLASH_ESCAPES"

事务与隔离级别
--------------

事务及其属性
~~~~~~~~~~~~

事务是由一组SQL语句组成的逻辑处理单元，事务具有以下4个属性，通常简称为事务的ACID属性。

-  原子性（Atomicity）

事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。

-  一致性（Consistent）

在事务开始和完成时，数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改，以保持数据的完整性；事务结束时，所有的内部数据结构（如B树索引或双向链表）也都必须是正确的。

-  隔离性（Isolation）

数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的，反之亦然。

-  持久性（Durable）

事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。

并发事务处理带来的问题
~~~~~~~~~~~~~~~~~~~~~~

相对于串行处理来说，并发事务处理能大大增加数据库资源的利用率，提高数据库系统的事务吞吐量，从而可以支持更多的用户。但并发事务处理也会带来一些问题，主要包括以下几种情况：

-  更新丢失（Lost Update）

当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题－－最后的更新覆盖了由其他事务所做的更新。

-  脏读（Dirty Reads）

一个事务正在对一条记录做修改，在这个事务完成并提交前，这条记录的数据就处于不一致状态；这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些“脏”数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象地叫做"脏读"。

-  不可重复读（Non-Repeatable Reads）

一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了改变、或某些记录已经被删除了！这种现象就叫做“不可重复读”。

-  幻读（Phantom Reads）

一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读”。

事务隔离级别
~~~~~~~~~~~~

并发事务处理带来的问题中，“更新丢失”通常是应该完全避免的。但防止更新丢失，并不能单靠数据库事务控制器来解决，需要应用程序对要更新的数据加必要的锁来解决，因此，防止更新丢失应该是应用的责任。

“脏读”、“不可重复读”和“幻读”，其实都是数据库读一致性问题，必须由数据库提供一定的事务隔离机制来解决。数据库实现事务隔离的方式，基本上可分为以下两种。

-  一种是在读取数据前，对其加锁，阻止其他事务对数据进行修改。

-  另一种是不用加任何锁，通过一定机制生成一个数据请求时间点的一致性数据快照（Snapshot)，并用这个快照来提供一定级别（语句级或事务级）的一致性读取。从用户的角度来看，好象是数据库可以提供同一数据的多个版本，因此，这种技术叫做数据多版本并发控制（MultiVersion
   Concurrency Control，简称MVCC或MCC），也经常称为多版本数据库。

数据库的事务隔离越严格，并发副作用越小，但付出的代价也就越大，因为事务隔离实质上就是使事务在一定程度上“串行化”进行，这显然与“并发”是矛盾的。同时，不同的应用对读一致性和事务隔离程度的要求也是不同的，比如许多应用对“不可重复读”和“幻读”并不敏感，可能更关心数据并发访问的能力。

为了解决“隔离”与“并发”的矛盾，ISO/ANSI
SQL92定义了4个事务隔离级别，每个级别的隔离程度不同，允许出现的副作用也不同，应用可以根据自己的业务逻辑要求，通过选择不同的隔离级别来平衡“隔离”与“并发”的矛盾。

::

    +------------------------------------------------------------------+
    | 隔离级别                   | 读数据一致性    | 脏读 | 不可重复读 | 幻读  |
    +------------------------------------------------------------------+
    | 未提交读(Read uncommitted) | 最低级别       | 是   | 是       | 是    |
    +------------------------------------------------------------------+
    | 已提交度(Read committed)   | 语句级         | 否   | 是       | 是   |
    +------------------------------------------------------------------+
    | 可重复读(Repeatable read)  | 事务级         | 否   | 否       | 是   |
    +------------------------------------------------------------------+
    | 可序列化(Serializable)     | 最高级别，事务级 | 否   | 否       | 否   |
    +------------------------------------------------------------------+

较低的隔离级别 = 较好的性能

MySQL默认的隔离级别是 Repeatable read

推荐使用Read
committed，binlog格式使用mixed或是Row，因为基于语句复制不支持Read
committed隔离级别。

TIMESTAMP
---------

精度
~~~~

在临时值、临时函数的参数或返回值中可以使用小数秒，最大精度为6位小数，即微秒。超过6位小数，超过部分将会被四舍五入至微秒。

::

    mysql> SELECT MICROSECOND('2010-12-10 14:12:09.019473');
    +-------------------------------------------+
    | MICROSECOND('2010-12-10 14:12:09.019473') |
    +-------------------------------------------+
    |                                     19473 |
    +-------------------------------------------+

    mysql> SELECT MICROSECOND('2010-12-10 14:12:09.0194735');
    +--------------------------------------------+
    | MICROSECOND('2010-12-10 14:12:09.0194735') |
    +--------------------------------------------+
    |                                      19474 |
    +--------------------------------------------+

在存储时，如果建表语句中未指定TIMESTAMP字段的精度，整个小数部分会被四舍五入至秒。

::

    mysql> CREATE TABLE fractest1
    ( c1 TIME, c2 DATETIME, c3 TIMESTAMP );
    Query OK, 0 rows affected (0.03 sec)

    mysql> INSERT INTO fractest1 VALUES
    ('17:51:04.123456', '2014-09-08 17:51:04.654321',
    '2014-09-08 17:51:04.567890');
    Query OK, 1 row affected (0.00 sec)

    mysql> SELECT * FROM fractest1;
    +----------+---------------------+---------------------+
    | c1        | c2                      | c3             |
    +----------+---------------------+---------------------+
    | 17:51:04 | 2014-09-08 17:51:05 | 2014-09-08 17:51:05 |
    +----------+---------------------+---------------------+

如果建表语句中指定TIMESTAMP字段的精度，则超过精度部分会被四舍五入。

::

    mysql> CREATE TABLE fractest2
    ( c1 TIME(2), c2 DATETIME(3), c3 TIMESTAMP(6) );
    Query OK, 0 rows affected (0.04 sec)

    mysql> INSERT INTO fractest2 VALUES
    ('17:51:04.123456', '2014-09-08 17:51:04.654321', 
    '2014-09-08 17:51:04.5678905');
    Query OK, 1 row affected (0.01 sec)

    mysql> SELECT * FROM fractest2;
    +-------------+-------------------------+----------------------------
    | c1            | c2                          | c3                             |
    +-------------+-------------------------+----------------------------
    | 17:51:04.12 | 2014-09-08 17:51:04.654 | 2014-09-08 17:51:04.567891 |
    +-------------+-------------------------+----------------------------

初始化
~~~~~~

一张表中可以有任意多个TIMESTAMP字段可以被自动初始化或更新成当前时间戳current
timestamp。

explicit\_defaults\_for\_timestamp选项
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

启动服务时，如果未打开explicit\_defaults\_for\_timestamp选项，则会报警：

.. code:: sql

    [Warning] TIMESTAMP with implicit DEFAULT value is deprecated.
    Please use --explicit_defaults_for_timestamp server option 
    (see documentation for more details).

explicit\_defaults\_for\_timestamp选项，行为如下：

1. TIMESTAMP字段如果没有显示地声明为NOT NULL，则默认为NULL。
2. 任何一个TIMESTAMP字段都不会被自动设置为DEFAULT CURRENT\_TIMESTAMP 或
   ON UPDATE CURRENT\_TIMESTAMP，如果需要这些属性都需显示地指定。
3. TIMESTAMP字段被声明为NOT NULL且无默认值，建表语句不会自动设默认值。
4. 不指定TIMESTAMP字段值插入时，结果取决于SQL Mode：如果Strict SQL
   Mode打开，插入会报错。如果Strict SQL
   Mode未打开，这个字段会被赋值为'0000-00-00 00:00:00'，且会报警。

总结
----

综上所述，建议使用如下配置使用数据库：

::

    .../my.cnf

    [mysqld]
    #默认服务器端字符集
    character_set_server=utf8          
    #填充、转义类db2特性
    sql_mode="STRICT_TRANS_TABLES,PAD_CHAR_TO_FULL_LENGTH,NO_BACKSLASH_ESCAPES"

    ## timestamp
    explicit_defaults_for_timestamp

    [client]
    #客户端使用字符集
    default-character-set=utf8         

对于pagesize为16K的linux系统，数据库设计时，单条记录大小不能超过8K，单列索引字段大小不能超过767B，组合索引字段总大小不能超过3072B。